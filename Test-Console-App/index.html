<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta charset="utf-8" />
        <title>JavaScript Decryption Test</title>
    </head>
    <body>
        <h1>Test for encryption/decryption between JS and C#</h1>
        <p>
            .NET Core and JavaScript Encryption Decryption Library<br />(c) by Smart In Media, MIT License<br />
            <br />
            Let's assume, the JS now received the data from C#:<br />
            <br />We have: <br />
            Encrypted data in C# results in a JSON string, which can be also decrypted on the JS side (and vice versa): 
            <br/>'{
            <br />"DerivationType": "scrypt",
            <br />"Salt": "14beb3414afb8a1de8604de90a05407de29a280336a7b4aee5876bda55ab137f",
            <br />"Cost": 16384,
            <br />"BlockSize": 8,
            <br />"Parallel": 1,
            <br />"KeySizeInBytes": 32,
            <br />"DerivationIterations": 0,
            <br />"AesRijndaelIv": "35Gtt04sMAzf+9lMNDPr+Q==",
            <br />"CipherOutputText": "hWvekGAS39AN8SAyHbfjXYlyjhKPQXE2zOmgJVVpihE="
            <br />}'
            <br />and the passphrase: This_is_my_password!
            <br />Please note that the C# side also has a password generator (PasswordGenerator.GenerateRandomPassword(20); for password length of 20 characters, you can define the character set)
            <br />
            <br />
            <strong><span id="output"></span></strong>


            <br />
            <br />
        </p>
        <h1>Test for hashing with Scrypt</h1>
        <p>
            There is also an implementation for Scrypt. Scrypt is a new(er) way to hash passwords more securely, if
            <br />you want to store them in your database, etc. Scrypt takes longer to hash - you can set it according
            <br />to hardware performance. I. e. you can define that hashing a password takes a second on a fast machine.
            <br />The purpose of that is to make brute force (and dictionary) attacks considerably harder for attackers.
            <br />
            You can run Scrypt asynchronously and get a progress (plus you can cancel) by passing a callback function.
            Scrypt will pass the hash key to that callback function. If you omit the callback function, then Scrypt runs
            synchronously and returns the key. So either, you run sH.Hash(password, options, callback);
            or you run var key = sH.Hash(password, options);

            <strong>Progress: <span id="progress"></span></strong>
            <br />

            <strong><span id="outputScrypt"></span></strong>
            <br /><br />
            <strong><span id="outputScrypt-synch"></span></strong>
        </p>
        <script type="text/javascript" src="./crypto-js.min.js"></script>
        <script type="text/javascript" src="./scrypt.min.js"></script>

        <script type="text/javascript" src="./encryptionHandler.js"></script>
        <script type="text/javascript" src="./scryptHandler.js"></script>
        <script type="text/javascript">

            // Test AES
            // This is the ciphertext, which was encrypted by C# to check the interchangeability:
            //var encryptedBase64FromCSharp = '{"DerivationType": "scrypt","Salt": "MmTt71gekdK62HbCD2ZUUkYBwVpMB6aWzYGJg+eUvBM=","Cost": 16384,"BlockSize": 8,"Parallel": 1,"KeySizeInBytes": 32,"DerivationIterations": 0,"AesRijndaelIv": "eIUwJ0pzcnr1HmSIVX4Qhw==","CipherOutputText": "BBhxsgDxth1u03appq/WIlXV+wbhUm7CMLZ/NazdJRA="}';
            //var encryptedBase64FromCSharp ='{"DerivationType": "rfc","Salt": "ZPVKtxxU+ZOBcA5FMCGIrLCJhItZQr9xkhzw4GyXk1A=","Cost": 0,"BlockSize": 0,"Parallel": 0,"KeySizeInBytes": 32,"DerivationIterations": 10000,"AesRijndaelIv": "3aF7jwcjXiEkuPOn8oqK0g==","CipherOutputText": "rKn+tl0Y4xyPqtQ/kfz1yhgh0pckTHxhayLAPNF4vIA="}';
            var encryptedBase64FromCSharp = '{"DerivationType": "scrypt", "Salt": "3a069e9126af66a839067f8a272081136d8ce63ed72176dc8a29973d2b15361f", "Cost": 16384, "BlockSize": 8, "Parallel": 1, "KeySizeInBytes": 32, "DerivationIterations": 0, "AesRijndaelIv": "NrCMq2XZ/woLCBq2haKPtQ==", "CipherOutputText": "8Llal3i445vIVWRIHsMQHdaJlpYoubcjmFczH0t7tEA="}';
            var passPhrase = "This_is_my_password!";

            var eH = new encryptionHandler();


            var decryptedFromCSharp = eH.decrypt(encryptedBase64FromCSharp, passPhrase);

            var spanEnc = document.getElementById("output");


            var outputText = "The decrypted text from C#: " + decryptedFromCSharp;
            spanEnc.innerHTML = outputText;
            var encryptTextWithJs = eH.encrypt(decryptedFromCSharp, "This_is_my_password!");

            var decryptedTextWithJs = eH.decrypt(encryptTextWithJs, "This_is_my_password!");
            outputText += "<br>And now this was encrypted and decrypted again with JS: " + decryptedTextWithJs;
            spanEnc.innerHTML = outputText;

            //
            // Test Scrypt
            //
            var outputText2 = "<br><br>Testing Scrypt<br> with password = 'This_is_my_password!' and salt = 'This_is_my_SALT!'";
            var password = "This_is_my_password!";
            var saltString = "This_is_my_SALT!";

            //SALT must be delivered as Hex!!
            var wr = CryptoJS.enc.Utf8.parse(saltString);
            var salt = CryptoJS.enc.Hex.stringify(wr);
            
            var t0 = (new Date()).getTime(); //To measure time!
            /*
             You can add any of these options
            var options =
                {
                      "salt": string, //(can be empty or null, then string is automatically created)
                      "cost": int, //(the "N" of scrypt, default is 16384)
                      "blockSize": int, // (the "r", default is 8)
                      "parallel": int, // (the "p", default is 1)
                      "derivedKeyLength": int // (default is 32)
                }
            */
            var sH = new scryptHandler();

            var options = { "salt": salt };
            var callback = function (error, progress, key) {
                if (error) {
                    outputText2 += "There was an error: " + error;
                }
                else if (key) {
                    outputText2 += "<br/>The key string for password " + password + " is: " + key;
                    outputText2 += "<br/>It is compatible with C# as long as you leave maxThreads in C# at null";
                    outputText2 += "<br>Execution time: " + (((new Date()).getTime() - t0) / 1000) + ' seconds';
                    var spanScrypt = document.getElementById("outputScrypt");
                    spanScrypt.innerHTML = outputText2;
                    sH.comparePasswordWithHash(password,
                        key,
                        function (isTheSame) {
                            if (isTheSame) {

                                var spanScrypt = document.getElementById("outputScrypt");
                                spanScrypt.innerHTML =
                                    spanScrypt.innerHTML + "<br/>Checking the password vs hash: matches!";

                            } else {
                                var spanScrypt = document.getElementById("outputScrypt");
                                spanScrypt.innerHTML =
                                    spanScrypt.innerHTML + "<br/>Checking the password vs hash: does not match!";

                            }
                        });

                }

                else if (progress) {
                    var spanProgress = document.getElementById("progress");

                    spanProgress.innerHTML = (((progress * 100).toFixed()).toString() + "%");
                }

            }
            
            sH.Hash(password, options, callback);
            var spanScryptsynch = document.getElementById("outputScrypt-synch");
            
            var sH2 = new scryptHandler();
            var synchKey = sH2.Hash(passPhrase, options);
            spanScryptsynch.innerHTML = "<br/><br/>You can also get the key synchronously without callback function: " +
                synchKey;
            if (sH2.comparePasswordWithHash(passPhrase, synchKey)) {
                spanScryptsynch.innerHTML +=
                    "<br/>And the derived hash key matches with the test (also in synchronous mode)!";
            } else {
                spanScryptsynch.innerHTML +=
                    "<br/>The derived hash key do not match with the test (in synchronous mode)!";
            }

            var testHash = sH2.Hash("This_is_my_password!", { "Salt": eH.transformTextToHex("1") });
            spanScryptsynch.innerHTML +=
                "<br/><br/>The derived password with a given string Salt is: " + testHash;
                
        </script>

    </body>
</html>